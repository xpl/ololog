"use strict";

/*  ------------------------------------------------------------------------ */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if ("value" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var O = Object,
    StackTracey = require('stacktracey'),
    ansi = require('ansicolor'),
    bullet = require('string.bullet'),
    pipez = require('pipez');

/*  ------------------------------------------------------------------------ */

var _stringify = require('string.ify').configure({
    formatter: function formatter(x, stringify) {

        if (x instanceof Error && !(typeof Symbol !== 'undefined' && x[Symbol.for('String.ify')])) {

            if (stringify.state.depth > 0) return '<Error: ' + x.message + '>'; // prevents unwanted pretty printing for Errors that are properties of complex objects

            var indent = '    ',
                why = stringify.limit((x.message || '').replace(/\r|\n/g, '').trim(), stringify.state.maxErrorMessageLength || 120),
                stack = new StackTracey(x).pretty,
                stackIndented = stack.split('\n').map(function (x) {
                return indent + x;
            }).join('\n'),
                isAssertion = 'actual' in x && 'expected' in x,
                type = x.constructor.name || 'Error';

            if (isAssertion) {

                var str = stringify.configure({ maxStringLength: Number.MAX_VALUE, maxDepth: 8 });

                var actual = bullet(indent + 'actual:   ', str(x.actual)),
                    expected = bullet(indent + 'expected: ', str(x.expected));

                if (actual.split('\n').length > 1 || expected.split('\n').length > 1) // if multiline actual/expected, need extra whitespace inbetween
                    actual += '\n';

                return '[' + type + '] ' + why + '\n\n' + ansi.red(actual) + '\n' + ansi.green(expected) + '\n\n' + stackIndented + '\n';
            } else {
                return '[' + type + '] ' + why + '\n\n' + stackIndented + '\n';
            }
        }
    }
});

/*  ------------------------------------------------------------------------ */

var _require = require('printable-characters'),
    isBlank = _require.isBlank,
    blank = _require.blank,
    changeLastNonemptyLine = function changeLastNonemptyLine(lines, fn) {

    for (var i = lines.length - 1; i >= 0; i--) {

        if (i === 0 || !isBlank(lines[i])) {

            lines[i] = fn(lines[i]);
            break;
        }
    }
    return lines;
};

/*  ------------------------------------------------------------------------ */

var log = pipez({

    /*  ------------------------------------------------------------------------ */

    stringify: function stringify(args, cfg) {
        var print = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cfg.print || _stringify.configure(cfg);
        return args.map(function (arg) {
            return typeof arg === 'string' ? arg : print(arg);
        });
    },

    trim: function trim(tokens, _ref) {
        var _ref$max = _ref.max,
            max = _ref$max === undefined ? undefined : _ref$max;
        return !max ? tokens : tokens.map(function (t) {
            return _stringify.limit(t, max);
        });
    },

    lines: function lines(tokens, _ref2) {
        var _ref2$linebreak = _ref2.linebreak,
            linebreak = _ref2$linebreak === undefined ? '\n' : _ref2$linebreak;


        var lines = [[]];
        var leftPad = [];

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var t = _step.value;

                var _t$split = t.split(linebreak),
                    _t$split2 = _toArray(_t$split),
                    first = _t$split2[0],
                    rest = _t$split2.slice(1);

                lines[lines.length - 1].push(first);
                lines = [].concat(_toConsumableArray(lines), _toConsumableArray(rest.map(function (t) {
                    return t ? [].concat(leftPad, [t]) : [];
                })));

                var pad = blank(!rest.length ? t : rest[rest.length - 1]);

                if (pad) {
                    leftPad.push(pad);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return lines;
    },

    concat: function concat(lines, _ref3) {
        var _ref3$separator = _ref3.separator,
            separator = _ref3$separator === undefined ? ' ' : _ref3$separator;
        return lines.map(function (tokens) {
            return tokens.join(separator);
        });
    },

    indent: function indent(lines, _ref4) {
        var _ref4$level = _ref4.level,
            level = _ref4$level === undefined ? 0 : _ref4$level,
            _ref4$pattern = _ref4.pattern,
            pattern = _ref4$pattern === undefined ? '\t' : _ref4$pattern;
        return lines.map(function (line) {
            return pattern.repeat(level) + line;
        });
    },

    tag: function tag(lines, _ref5) {
        var _ref5$level = _ref5.level,
            level = _ref5$level === undefined ? '' : _ref5$level,
            _ref5$levelColor = _ref5.levelColor,
            levelColor = _ref5$levelColor === undefined ? {
            'info': ansi.cyan,
            'warn': ansi.yellow,
            'debug': ansi.blue,
            'error': ansi.bright.red } : _ref5$levelColor;
        return bullet((levelColor[level] || function (s) {
            return s;
        })(level.toUpperCase().padStart(6) + '\t'), lines);
    },

    time: function time(lines, _ref6) {
        var _ref6$when = _ref6.when,
            when = _ref6$when === undefined ? new Date() : _ref6$when,
            _ref6$format = _ref6.format,
            format = _ref6$format === undefined ? 'locale' : _ref6$format,
            _ref6$print = _ref6.print,
            print = _ref6$print === undefined ? function (when) {
            return ansi.darkGray(format === 'iso' ? when.toISOString() : format === 'locale' ? when.toLocaleString() : format === 'utc' ? when.toUTCString() : when.toString()) + '\t';
        } : _ref6$print;
        return bullet(print(when), lines);
    },

    locate: function locate(lines, _ref7) {
        var _ref7$shift = _ref7.shift,
            shift = _ref7$shift === undefined ? 0 : _ref7$shift,
            _ref7$where = _ref7.where,
            where = _ref7$where === undefined ? new StackTracey().clean.at(1 + shift) : _ref7$where,
            _ref7$join = _ref7.join,
            join = _ref7$join === undefined ? function (a, sep, b) {
            return a && b ? a + sep + b : a || b;
        } : _ref7$join,
            _ref7$print = _ref7.print,
            print = _ref7$print === undefined ? function (_ref8) {
            var calleeShort = _ref8.calleeShort,
                _ref8$fileName = _ref8.fileName,
                fileName = _ref8$fileName === undefined ? [] : _ref8$fileName,
                _ref8$line = _ref8.line,
                line = _ref8$line === undefined ? [] : _ref8$line;
            return ansi.darkGray('(' + join(calleeShort, ' @ ', join(fileName, ':', line)) + ')');
        } : _ref7$print;
        return changeLastNonemptyLine(lines, function (line) {
            return join(line, ' ', print(where));
        });
    },

    join: function join(lines, _ref9) {
        var _ref9$linebreak = _ref9.linebreak,
            linebreak = _ref9$linebreak === undefined ? '\n' : _ref9$linebreak;
        return lines.join(linebreak);
    },

    render: function render(text, _ref10) {
        var _ref10$engine = _ref10.engine,
            engine = _ref10$engine === undefined ? typeof window !== 'undefined' && window.window === window && window.navigator ? navigator.userAgent.indexOf('Chrome') >= 0 ? 'chrome' : 'generic' : 'ansi' : _ref10$engine,
            _ref10$engines = _ref10.engines,
            engines = _ref10$engines === undefined ? {/* configurable */} : _ref10$engines,
            _ref10$consoleMethod = _ref10.consoleMethod,
            consoleMethod = _ref10$consoleMethod === undefined ? 'log' : _ref10$consoleMethod,
            _ref10$defaults = _ref10.defaults,
            defaults = _ref10$defaults === undefined ? {

            ansi: function ansi(s) {
                return console[consoleMethod](s);
            },
            chrome: function chrome(s) {
                var _console;

                return (_console = console)[consoleMethod].apply(_console, _toConsumableArray(ansi.parse(s).asChromeConsoleLogArguments));
            },
            generic: function generic(s) {
                return console[consoleMethod](ansi.strip(s));
            }
        } : _ref10$defaults;
        return text && O.assign(defaults, engines)[engine](text), text;
    },

    returnValue: function returnValue(__, _ref11) {
        var _ref11$initialArgumen = _slicedToArray(_ref11.initialArguments, 1),
            firstArgument = _ref11$initialArgumen[0];

        return firstArgument;
    }

    /*  ------------------------------------------------------------------------ */

}).configure({

    time: false, // disables some steps (until enabled back explicitly)
    tag: false

    /*  ------------------------------------------------------------------------ */

}).methods({

    get noop() {
        return pipez({ returnValue: function returnValue(args) {
                return args[0];
            } }).methods(this.methods_);
    },
    get null() {
        return this.noop;
    }, // LEGACY, DEPRECATED (left here for backward compatibility)

    indent: function indent(level) {
        return this.configure({ indent: { level: level } });
    },


    get error() {
        return this.configure({ tag: { level: 'error' }, render: { consoleMethod: 'error' } });
    },
    get warn() {
        return this.configure({ tag: { level: 'warn' }, render: { consoleMethod: 'warn' } });
    },
    get info() {
        return this.configure({ tag: { level: 'info' }, render: { consoleMethod: 'info' } });
    },
    get debug() {
        return this.configure({ tag: { level: 'debug' }, render: { consoleMethod: 'debug' } });
    },

    maxArrayLength: function maxArrayLength(n) {
        return this.configure({ stringify: { maxArrayLength: n } });
    },
    maxObjectLength: function maxObjectLength(n) {
        return this.configure({ stringify: { maxObjectLength: n } });
    },
    maxDepth: function maxDepth(n) {
        return this.configure({ stringify: { maxDepth: n } });
    },
    maxLength: function maxLength(n) {
        return this.configure({ stringify: { maxLength: n } });
    },


    get unlimited() {
        return this.configure({ stringify: { maxStringLength: Number.MAX_VALUE,
                maxObjectLength: Number.MAX_VALUE,
                maxArrayLength: Number.MAX_VALUE,
                maxDepth: Number.MAX_VALUE,
                maxErrorMessageLength: Number.MAX_VALUE } });
    },

    get noPretty() {
        return this.configure({ stringify: { pretty: false } });
    },
    get noFancy() {
        return this.configure({ stringify: { fancy: false } });
    },
    get noRightAlignKeys() {
        return this.configure({ stringify: { rightAlignKeys: false } });
    },
    get noLocate() {
        return this.configure({ locate: false });
    },
    precision: function precision(n) {
        return this.configure({ stringify: { precision: n } });
    },


    get serialize() {
        return this.before('render');
    },
    get deserialize() {
        return this.from('render');
    },

    newline: function newline() {
        return this.from('join')(['']);
    },
    handleNodeErrors: function handleNodeErrors() {
        var _this = this;

        process.on('uncaughtException', function (e) {
            _this.bright.red.error.noLocate(e);process.exit(1);
        });
        process.on('unhandledRejection', function (e) {
            _this.bright.red.error.noLocate(e);process.exit(1);
        });
        return this;
    }
});

/*  ------------------------------------------------------------------------ */

ansi.names.forEach(function (color) {
    var _log$methods, _mutatorMap;

    log.methods((_log$methods = {}, _mutatorMap = {}, _mutatorMap[color] = _mutatorMap[color] || {}, _mutatorMap[color].get = function () {
        return this.configure({ 'concat+': function concat(lines) {
                return lines.map(ansi[color]);
            } });
    }, _defineEnumerableProperties(_log$methods, _mutatorMap), _log$methods));
});

/*  ------------------------------------------------------------------------ */

module.exports = log;

/*  ------------------------------------------------------------------------ */

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixDQUFnQyxDQUFoQyxFQUFvQyxRQUFRLElBQVIsQ0FBYyxDQUFkO0FBQWtCLFNBQS9GO0FBQ0EsZ0JBQVEsRUFBUixDQUFZLG9CQUFaLEVBQWtDLGFBQUs7QUFBRSxrQkFBSyxNQUFMLENBQVksR0FBWixDQUFnQixLQUFoQixDQUFzQixRQUF0QixDQUFnQyxDQUFoQyxFQUFvQyxRQUFRLElBQVIsQ0FBYyxDQUFkO0FBQWtCLFNBQS9GO0FBQ0EsZUFBTyxJQUFQO0FBQ0g7QUF0Q08sQ0E3RkEsQ0FBWjs7QUFzSUE7O0FBRUEsS0FBSyxLQUFMLENBQVcsT0FBWCxDQUFvQixpQkFBUztBQUFBOztBQUV6QixRQUFJLE9BQUosbURBRVMsS0FGVCxnQkFFUyxLQUZULHFCQUVTLEtBRlQsb0JBRW1CO0FBQUUsZUFBTyxLQUFLLFNBQUwsQ0FBZ0IsRUFBRSxXQUFXO0FBQUEsdUJBQVMsTUFBTSxHQUFOLENBQVcsS0FBSyxLQUFMLENBQVgsQ0FBVDtBQUFBLGFBQWIsRUFBaEIsQ0FBUDtBQUF5RSxLQUY5RjtBQUlILENBTkQ7O0FBUUE7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLEdBQWpCOztBQUVBIiwiZmlsZSI6Im9sb2xvZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNvbnN0IE8gICAgICAgICAgICAgICAgID0gT2JqZWN0XG4gICAgLCBTdGFja1RyYWNleSAgICAgICA9IHJlcXVpcmUgKCdzdGFja3RyYWNleScpXG4gICAgLCBhbnNpICAgICAgICAgICAgICA9IHJlcXVpcmUgKCdhbnNpY29sb3InKVxuICAgICwgYnVsbGV0ICAgICAgICAgICAgPSByZXF1aXJlICgnc3RyaW5nLmJ1bGxldCcpXG4gICAgLCBwaXBleiAgICAgICAgICAgICA9IHJlcXVpcmUgKCdwaXBleicpXG5cbi8qICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5jb25zdCBzdHJpbmdpZnkgPSByZXF1aXJlICgnc3RyaW5nLmlmeScpLmNvbmZpZ3VyZSAoe1xuXG4gICAgZm9ybWF0dGVyICh4LCBzdHJpbmdpZnkpIHtcblxuICAgICAgICBpZiAoKHggaW5zdGFuY2VvZiBFcnJvcikgJiYgISh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiB4W1N5bWJvbC5mb3IgKCdTdHJpbmcuaWZ5JyldKSkge1xuXG4gICAgICAgICAgICBpZiAoc3RyaW5naWZ5LnN0YXRlLmRlcHRoID4gMCkgcmV0dXJuIGA8RXJyb3I6ICR7eC5tZXNzYWdlfT5gIC8vIHByZXZlbnRzIHVud2FudGVkIHByZXR0eSBwcmludGluZyBmb3IgRXJyb3JzIHRoYXQgYXJlIHByb3BlcnRpZXMgb2YgY29tcGxleCBvYmplY3RzXG5cbiAgICAgICAgICAgIGNvbnN0IGluZGVudCAgICAgICAgPSAnICAgICdcbiAgICAgICAgICAgICAgICAsIHdoeSAgICAgICAgICAgPSBzdHJpbmdpZnkubGltaXQgKCh4Lm1lc3NhZ2UgfHwgJycpLnJlcGxhY2UgKC9cXHJ8XFxuL2csICcnKS50cmltICgpLCBzdHJpbmdpZnkuc3RhdGUubWF4RXJyb3JNZXNzYWdlTGVuZ3RoIHx8IDEyMClcbiAgICAgICAgICAgICAgICAsIHN0YWNrICAgICAgICAgPSBuZXcgU3RhY2tUcmFjZXkgKHgpLnByZXR0eVxuICAgICAgICAgICAgICAgICwgc3RhY2tJbmRlbnRlZCA9IHN0YWNrLnNwbGl0ICgnXFxuJykubWFwICh4ID0+IGluZGVudCArIHgpLmpvaW4gKCdcXG4nKVxuICAgICAgICAgICAgICAgICwgaXNBc3NlcnRpb24gPSAoJ2FjdHVhbCcgaW4geCkgJiYgKCdleHBlY3RlZCcgaW4geClcbiAgICAgICAgICAgICAgICAsIHR5cGUgICAgICAgID0geC5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdFcnJvcidcblxuICAgICAgICAgICAgaWYgKGlzQXNzZXJ0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzdHIgPSBzdHJpbmdpZnkuY29uZmlndXJlICh7IG1heFN0cmluZ0xlbmd0aDogTnVtYmVyLk1BWF9WQUxVRSwgbWF4RGVwdGg6IDggfSlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgYWN0dWFsICAgPSBidWxsZXQgKGluZGVudCArICdhY3R1YWw6ICAgJywgc3RyICh4LmFjdHVhbCkpXG4gICAgICAgICAgICAgICAgICAsIGV4cGVjdGVkID0gYnVsbGV0IChpbmRlbnQgKyAnZXhwZWN0ZWQ6ICcsIHN0ciAoeC5leHBlY3RlZCkpXG5cbiAgICAgICAgICAgICAgICBpZiAoKGFjdHVhbC5zcGxpdCAoJ1xcbicpLmxlbmd0aCA+IDEpIHx8IChleHBlY3RlZC5zcGxpdCAoJ1xcbicpLmxlbmd0aCA+IDEpKSAvLyBpZiBtdWx0aWxpbmUgYWN0dWFsL2V4cGVjdGVkLCBuZWVkIGV4dHJhIHdoaXRlc3BhY2UgaW5iZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbCArPSAnXFxuJ1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBbJHt0eXBlfV0gJHt3aHl9XFxuXFxuJHthbnNpLnJlZCAoYWN0dWFsKX1cXG4ke2Fuc2kuZ3JlZW4gKGV4cGVjdGVkKX1cXG5cXG4ke3N0YWNrSW5kZW50ZWR9XFxuYFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYFske3R5cGV9XSAke3doeX1cXG5cXG4ke3N0YWNrSW5kZW50ZWR9XFxuYFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSlcblxuLyogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5jb25zdCB7IGlzQmxhbmssIGJsYW5rIH0gPSByZXF1aXJlICgncHJpbnRhYmxlLWNoYXJhY3RlcnMnKVxuXG4gICAgLCBjaGFuZ2VMYXN0Tm9uZW1wdHlMaW5lID0gKGxpbmVzLCBmbikgPT4ge1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoKGkgPT09IDApIHx8ICFpc0JsYW5rIChsaW5lc1tpXSkpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IGZuIChsaW5lc1tpXSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXNcbiAgICB9XG5cbi8qICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuY29uc3QgbG9nID0gcGlwZXogKHtcblxuLyogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgc3RyaW5naWZ5OiAoYXJncywgY2ZnLCBwcmludCA9IGNmZy5wcmludCB8fCBzdHJpbmdpZnkuY29uZmlndXJlIChjZmcpKSA9PiBhcmdzLm1hcCAoYXJnID0+ICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykgPyBhcmcgOiBwcmludCAoYXJnKSksXG4gICAgXG4gICAgdHJpbTogKHRva2VucywgeyBtYXggPSB1bmRlZmluZWQgfSkgPT4gIW1heCA/IHRva2VucyA6IHRva2Vucy5tYXAgKHQgPT4gc3RyaW5naWZ5LmxpbWl0ICh0LCBtYXgpKSxcblxuICAgIGxpbmVzOiAodG9rZW5zLCB7IGxpbmVicmVhayA9ICdcXG4nIH0pID0+IHtcblxuICAgICAgICBsZXQgbGluZXMgPSBbW11dXG4gICAgICAgIGxldCBsZWZ0UGFkID0gW11cblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdG9rZW5zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IFtmaXJzdCwgLi4ucmVzdF0gPSB0LnNwbGl0IChsaW5lYnJlYWspXG5cbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLnB1c2ggKGZpcnN0KVxuICAgICAgICAgICAgbGluZXMgPSBbLi4ubGluZXMsIC4uLnJlc3QubWFwICh0ID0+IHQgPyBbLi4ubGVmdFBhZCwgdF0gOiBbXSldXG5cbiAgICAgICAgICAgIGNvbnN0IHBhZCA9IGJsYW5rICghcmVzdC5sZW5ndGggPyB0IDogcmVzdFtyZXN0Lmxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGFkKSB7IGxlZnRQYWQucHVzaCAocGFkKSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXNcbiAgICB9LFxuXG4gICAgY29uY2F0OiAobGluZXMsIHsgc2VwYXJhdG9yID0gJyAnIH0pID0+IGxpbmVzLm1hcCAodG9rZW5zID0+IHRva2Vucy5qb2luIChzZXBhcmF0b3IpKSxcblxuICAgIGluZGVudDogKGxpbmVzLCB7IGxldmVsID0gMCwgcGF0dGVybiA9ICdcXHQnIH0pID0+IGxpbmVzLm1hcCAobGluZSA9PiBwYXR0ZXJuLnJlcGVhdCAobGV2ZWwpICsgbGluZSksXG4gICAgXG4gICAgdGFnOiAobGluZXMsIHsgbGV2ZWwgPSAnJyxcbiAgICAgICAgICAgICAgICAgICBsZXZlbENvbG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAnaW5mbyc6IGFuc2kuY3lhbixcbiAgICAgICAgICAgICAgICAgICAgICAgJ3dhcm4nOiBhbnNpLnllbGxvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgJ2RlYnVnJzogYW5zaS5ibHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InOiBhbnNpLmJyaWdodC5yZWQgfSB9KSA9PiBidWxsZXQgKChsZXZlbENvbG9yW2xldmVsXSB8fCAocyA9PiBzKSkgKGxldmVsLnRvVXBwZXJDYXNlICgpLnBhZFN0YXJ0ICg2KSArICdcXHQnKSwgbGluZXMpLFxuXG4gICAgdGltZTogKGxpbmVzLCB7IHdoZW4gICA9IG5ldyBEYXRlICgpLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSAnbG9jYWxlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQgID0gd2hlbiA9PiBhbnNpLmRhcmtHcmF5IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGZvcm1hdCA9PT0gJ2lzbycpICAgID8gd2hlbi50b0lTT1N0cmluZyAoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChmb3JtYXQgPT09ICdsb2NhbGUnKSA/IHdoZW4udG9Mb2NhbGVTdHJpbmcgKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZm9ybWF0ID09PSAndXRjJykgICAgPyB3aGVuLnRvVVRDU3RyaW5nICgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbi50b1N0cmluZyAoKSkpKSkgKyAnXFx0JyB9KSA9PiBidWxsZXQgKHByaW50ICh3aGVuKSwgbGluZXMpLFxuXG4gICAgbG9jYXRlOiAobGluZXMsIHtcblxuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlID0gKG5ldyBTdGFja1RyYWNleSAoKS5jbGVhbi5hdCAoMSArIHNoaWZ0KSksXG4gICAgICAgICAgICAgICAgICAgIGpvaW4gID0gKChhLCBzZXAsIGIpID0+IChhICYmIGIpID8gKGEgKyBzZXAgKyBiKSA6IChhIHx8IGIpKSxcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQgPSAoeyBjYWxsZWVTaG9ydCwgZmlsZU5hbWUgPSBbXSwgbGluZSA9IFtdIH0pID0+IGFuc2kuZGFya0dyYXkgKCcoJyArIGpvaW4gKGNhbGxlZVNob3J0LCAnIEAgJywgam9pbiAoZmlsZU5hbWUsICc6JywgbGluZSkpICsgJyknKVxuXG4gICAgICAgICAgICAgICAgfSkgPT4gY2hhbmdlTGFzdE5vbmVtcHR5TGluZSAobGluZXMsIGxpbmUgPT4gam9pbiAobGluZSwgJyAnLCBwcmludCAod2hlcmUpKSksXG5cbiAgICBqb2luOiAobGluZXMsIHsgbGluZWJyZWFrID0gJ1xcbicgfSkgPT4gbGluZXMuam9pbiAobGluZWJyZWFrKSxcblxuICAgIHJlbmRlcjogKHRleHQsIHtcblxuICAgICAgICBlbmdpbmUgPSAoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAod2luZG93LndpbmRvdyA9PT0gd2luZG93KSAmJiB3aW5kb3cubmF2aWdhdG9yKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mICgnQ2hyb21lJykgPj0gMClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdjaHJvbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2dlbmVyaWMnXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdhbnNpJyxcblxuICAgICAgICBlbmdpbmVzID0geyAvKiBjb25maWd1cmFibGUgKi8gfSxcblxuICAgICAgICBjb25zb2xlTWV0aG9kID0gJ2xvZycsXG5cbiAgICAgICAgZGVmYXVsdHMgPSB7XG5cbiAgICAgICAgICAgIGFuc2k6ICAgIHMgPT4gY29uc29sZVtjb25zb2xlTWV0aG9kXSAocyksXG4gICAgICAgICAgICBjaHJvbWU6ICBzID0+IGNvbnNvbGVbY29uc29sZU1ldGhvZF0gKC4uLmFuc2kucGFyc2UgKHMpLmFzQ2hyb21lQ29uc29sZUxvZ0FyZ3VtZW50cyksXG4gICAgICAgICAgICBnZW5lcmljOiBzID0+IGNvbnNvbGVbY29uc29sZU1ldGhvZF0gKGFuc2kuc3RyaXAgKHMpKVxuICAgICAgICB9XG5cbiAgICB9KSA9PiAoKHRleHQgJiYgTy5hc3NpZ24gKGRlZmF1bHRzLCBlbmdpbmVzKVtlbmdpbmVdICh0ZXh0KSwgdGV4dCkpLFxuXG4gICAgcmV0dXJuVmFsdWU6IChfXywgeyBpbml0aWFsQXJndW1lbnRzOiBbZmlyc3RBcmd1bWVudF0gfSkgPT4gZmlyc3RBcmd1bWVudFxuXG4vKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbn0pLmNvbmZpZ3VyZSAoe1xuXG4gICAgdGltZTogZmFsc2UsIC8vIGRpc2FibGVzIHNvbWUgc3RlcHMgKHVudGlsIGVuYWJsZWQgYmFjayBleHBsaWNpdGx5KVxuICAgIHRhZzogIGZhbHNlXG5cbi8qICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxufSkubWV0aG9kcyAoe1xuXG4gICAgZ2V0IG5vb3AgKCkgeyByZXR1cm4gcGlwZXogKHsgcmV0dXJuVmFsdWU6IGFyZ3MgPT4gYXJnc1swXSB9KS5tZXRob2RzICh0aGlzLm1ldGhvZHNfKSB9LFxuICAgIGdldCBudWxsICgpIHsgcmV0dXJuIHRoaXMubm9vcCB9LCAvLyBMRUdBQ1ksIERFUFJFQ0FURUQgKGxlZnQgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcblxuICAgIGluZGVudCAobGV2ZWwpIHsgcmV0dXJuIHRoaXMuY29uZmlndXJlICh7IGluZGVudDogeyBsZXZlbDogbGV2ZWwgfX0pIH0sXG5cbiAgICBnZXQgZXJyb3IgKCkgeyByZXR1cm4gdGhpcy5jb25maWd1cmUgKHsgdGFnOiB7IGxldmVsOiAnZXJyb3InIH0sIHJlbmRlcjogeyBjb25zb2xlTWV0aG9kOiAnZXJyb3InIH0gfSkgfSxcbiAgICBnZXQgd2FybiAoKSAgeyByZXR1cm4gdGhpcy5jb25maWd1cmUgKHsgdGFnOiB7IGxldmVsOiAnd2FybicgfSwgIHJlbmRlcjogeyBjb25zb2xlTWV0aG9kOiAnd2FybicgfSB9KSB9LFxuICAgIGdldCBpbmZvICgpICB7IHJldHVybiB0aGlzLmNvbmZpZ3VyZSAoeyB0YWc6IHsgbGV2ZWw6ICdpbmZvJyB9LCAgcmVuZGVyOiB7IGNvbnNvbGVNZXRob2Q6ICdpbmZvJyB9IH0pIH0sXG4gICAgZ2V0IGRlYnVnICgpICB7IHJldHVybiB0aGlzLmNvbmZpZ3VyZSAoeyB0YWc6IHsgbGV2ZWw6ICdkZWJ1ZycgfSwgIHJlbmRlcjogeyBjb25zb2xlTWV0aG9kOiAnZGVidWcnIH0gfSkgfSxcblxuICAgIG1heEFycmF5TGVuZ3RoIChuKSAgeyByZXR1cm4gdGhpcy5jb25maWd1cmUgKHsgc3RyaW5naWZ5OiB7IG1heEFycmF5TGVuZ3RoOiBuIH0gfSkgfSxcbiAgICBtYXhPYmplY3RMZW5ndGggKG4pIHsgcmV0dXJuIHRoaXMuY29uZmlndXJlICh7IHN0cmluZ2lmeTogeyBtYXhPYmplY3RMZW5ndGg6IG4gfSB9KSB9LFxuICAgIG1heERlcHRoIChuKSAgICAgICAgeyByZXR1cm4gdGhpcy5jb25maWd1cmUgKHsgc3RyaW5naWZ5OiB7IG1heERlcHRoOiBuIH0gfSkgfSxcbiAgICBtYXhMZW5ndGggKG4pICAgICAgIHsgcmV0dXJuIHRoaXMuY29uZmlndXJlICh7IHN0cmluZ2lmeTogeyBtYXhMZW5ndGg6IG4gfSB9KSB9LFxuICAgIFxuICAgIGdldCB1bmxpbWl0ZWQgKCkgeyByZXR1cm4gdGhpcy5jb25maWd1cmUgKHsgc3RyaW5naWZ5OiB7IG1heFN0cmluZ0xlbmd0aDogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhPYmplY3RMZW5ndGg6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4QXJyYXlMZW5ndGg6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGg6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RXJyb3JNZXNzYWdlTGVuZ3RoOiBOdW1iZXIuTUFYX1ZBTFVFIH0gfSkgfSxcblxuICAgIGdldCBub1ByZXR0eSAoKSB7IHJldHVybiB0aGlzLmNvbmZpZ3VyZSAoeyBzdHJpbmdpZnk6IHsgcHJldHR5OiBmYWxzZSB9IH0pIH0sXG4gICAgZ2V0IG5vRmFuY3kgKCkgeyByZXR1cm4gdGhpcy5jb25maWd1cmUgKHsgc3RyaW5naWZ5OiB7IGZhbmN5OiBmYWxzZSB9IH0pIH0sXG4gICAgZ2V0IG5vUmlnaHRBbGlnbktleXMgKCkgeyByZXR1cm4gdGhpcy5jb25maWd1cmUgKHsgc3RyaW5naWZ5OiB7IHJpZ2h0QWxpZ25LZXlzOiBmYWxzZSB9IH0pIH0sXG4gICAgZ2V0IG5vTG9jYXRlICgpIHsgcmV0dXJuIHRoaXMuY29uZmlndXJlICh7IGxvY2F0ZTogZmFsc2UgfSkgfSxcbiAgICBwcmVjaXNpb24gKG4pIHsgcmV0dXJuIHRoaXMuY29uZmlndXJlICh7IHN0cmluZ2lmeTogeyBwcmVjaXNpb246IG4gfSB9KSB9LFxuXG4gICAgZ2V0IHNlcmlhbGl6ZSAoKSB7IHJldHVybiB0aGlzLmJlZm9yZSAoJ3JlbmRlcicpIH0sXG4gICAgZ2V0IGRlc2VyaWFsaXplICgpIHsgcmV0dXJuIHRoaXMuZnJvbSAoJ3JlbmRlcicpIH0sXG5cbiAgICBuZXdsaW5lICgpIHsgcmV0dXJuIHRoaXMuZnJvbSAoJ2pvaW4nKShbJyddKSB9LFxuXG4gICAgaGFuZGxlTm9kZUVycm9ycyAoKSB7XG4gICAgICAgIHByb2Nlc3Mub24gKCd1bmNhdWdodEV4Y2VwdGlvbicsICBlID0+IHsgdGhpcy5icmlnaHQucmVkLmVycm9yLm5vTG9jYXRlIChlKTsgcHJvY2Vzcy5leGl0ICgxKSB9KVxuICAgICAgICBwcm9jZXNzLm9uICgndW5oYW5kbGVkUmVqZWN0aW9uJywgZSA9PiB7IHRoaXMuYnJpZ2h0LnJlZC5lcnJvci5ub0xvY2F0ZSAoZSk7IHByb2Nlc3MuZXhpdCAoMSkgfSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG59KVxuXG4vKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmFuc2kubmFtZXMuZm9yRWFjaCAoY29sb3IgPT4ge1xuXG4gICAgbG9nLm1ldGhvZHMgKHtcblxuICAgICAgICBnZXQgW2NvbG9yXSAoKSB7IHJldHVybiB0aGlzLmNvbmZpZ3VyZSAoeyAnY29uY2F0Kyc6IGxpbmVzID0+IGxpbmVzLm1hcCAoYW5zaVtjb2xvcl0pIH0pIH1cbiAgICB9KVxufSlcblxuLyogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ1xuXG4vKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuIl19